// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommMsgs.proto

#ifndef PROTOBUF_CommMsgs_2eproto__INCLUDED
#define PROTOBUF_CommMsgs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace snd_msgs {
class EmptyMsg;
class EmptyMsgDefaultTypeInternal;
extern EmptyMsgDefaultTypeInternal _EmptyMsg_default_instance_;
class Encoders;
class EncodersDefaultTypeInternal;
extern EncodersDefaultTypeInternal _Encoders_default_instance_;
class Ir;
class IrDefaultTypeInternal;
extern IrDefaultTypeInternal _Ir_default_instance_;
class Log;
class LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class PidTunings;
class PidTuningsDefaultTypeInternal;
extern PidTuningsDefaultTypeInternal _PidTunings_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class SerialRequest;
class SerialRequestDefaultTypeInternal;
extern SerialRequestDefaultTypeInternal _SerialRequest_default_instance_;
class SerialResponse;
class SerialResponseDefaultTypeInternal;
extern SerialResponseDefaultTypeInternal _SerialResponse_default_instance_;
class Speed;
class SpeedDefaultTypeInternal;
extern SpeedDefaultTypeInternal _Speed_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace snd_msgs

namespace snd_msgs {

namespace protobuf_CommMsgs_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_CommMsgs_2eproto

enum Log_eLogLevel {
  Log_eLogLevel_DEBUG = 0,
  Log_eLogLevel_INFO = 1,
  Log_eLogLevel_WARN = 2,
  Log_eLogLevel_ERROR = 3,
  Log_eLogLevel_FATAL = 4
};
bool Log_eLogLevel_IsValid(int value);
const Log_eLogLevel Log_eLogLevel_eLogLevel_MIN = Log_eLogLevel_DEBUG;
const Log_eLogLevel Log_eLogLevel_eLogLevel_MAX = Log_eLogLevel_FATAL;
const int Log_eLogLevel_eLogLevel_ARRAYSIZE = Log_eLogLevel_eLogLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* Log_eLogLevel_descriptor();
inline const ::std::string& Log_eLogLevel_Name(Log_eLogLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    Log_eLogLevel_descriptor(), value);
}
inline bool Log_eLogLevel_Parse(
    const ::std::string& name, Log_eLogLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Log_eLogLevel>(
    Log_eLogLevel_descriptor(), name, value);
}
enum eTeamColor {
  BLUE = 0,
  YELLOW = 1
};
bool eTeamColor_IsValid(int value);
const eTeamColor eTeamColor_MIN = BLUE;
const eTeamColor eTeamColor_MAX = YELLOW;
const int eTeamColor_ARRAYSIZE = eTeamColor_MAX + 1;

const ::google::protobuf::EnumDescriptor* eTeamColor_descriptor();
inline const ::std::string& eTeamColor_Name(eTeamColor value) {
  return ::google::protobuf::internal::NameOfEnum(
    eTeamColor_descriptor(), value);
}
inline bool eTeamColor_Parse(
    const ::std::string& name, eTeamColor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<eTeamColor>(
    eTeamColor_descriptor(), name, value);
}
// ===================================================================

class EmptyMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snd_msgs.EmptyMsg) */ {
 public:
  EmptyMsg();
  virtual ~EmptyMsg();

  EmptyMsg(const EmptyMsg& from);

  inline EmptyMsg& operator=(const EmptyMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmptyMsg& default_instance();

  static inline const EmptyMsg* internal_default_instance() {
    return reinterpret_cast<const EmptyMsg*>(
               &_EmptyMsg_default_instance_);
  }

  void Swap(EmptyMsg* other);

  // implements Message ----------------------------------------------

  inline EmptyMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  EmptyMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmptyMsg& from);
  void MergeFrom(const EmptyMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmptyMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:snd_msgs.EmptyMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct  protobuf_CommMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snd_msgs.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  inline Point* New() const PROTOBUF_FINAL { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:snd_msgs.Point)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  friend struct  protobuf_CommMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snd_msgs.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }

  void Swap(Pose* other);

  // implements Message ----------------------------------------------

  inline Pose* New() const PROTOBUF_FINAL { return New(NULL); }

  Pose* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float th = 3;
  bool has_th() const;
  void clear_th();
  static const int kThFieldNumber = 3;
  float th() const;
  void set_th(float value);

  // @@protoc_insertion_point(class_scope:snd_msgs.Pose)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_th();
  void clear_has_th();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float th_;
  friend struct  protobuf_CommMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Speed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snd_msgs.Speed) */ {
 public:
  Speed();
  virtual ~Speed();

  Speed(const Speed& from);

  inline Speed& operator=(const Speed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Speed& default_instance();

  static inline const Speed* internal_default_instance() {
    return reinterpret_cast<const Speed*>(
               &_Speed_default_instance_);
  }

  void Swap(Speed* other);

  // implements Message ----------------------------------------------

  inline Speed* New() const PROTOBUF_FINAL { return New(NULL); }

  Speed* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Speed& from);
  void MergeFrom(const Speed& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Speed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float left = 1;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  float left() const;
  void set_left(float value);

  // required float right = 2;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 2;
  float right() const;
  void set_right(float value);

  // @@protoc_insertion_point(class_scope:snd_msgs.Speed)
 private:
  void set_has_left();
  void clear_has_left();
  void set_has_right();
  void clear_has_right();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float left_;
  float right_;
  friend struct  protobuf_CommMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Encoders : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snd_msgs.Encoders) */ {
 public:
  Encoders();
  virtual ~Encoders();

  Encoders(const Encoders& from);

  inline Encoders& operator=(const Encoders& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Encoders& default_instance();

  static inline const Encoders* internal_default_instance() {
    return reinterpret_cast<const Encoders*>(
               &_Encoders_default_instance_);
  }

  void Swap(Encoders* other);

  // implements Message ----------------------------------------------

  inline Encoders* New() const PROTOBUF_FINAL { return New(NULL); }

  Encoders* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Encoders& from);
  void MergeFrom(const Encoders& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Encoders* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 left = 1;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  ::google::protobuf::int32 left() const;
  void set_left(::google::protobuf::int32 value);

  // required int32 right = 2;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 2;
  ::google::protobuf::int32 right() const;
  void set_right(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:snd_msgs.Encoders)
 private:
  void set_has_left();
  void clear_has_left();
  void set_has_right();
  void clear_has_right();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  friend struct  protobuf_CommMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PidTunings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snd_msgs.PidTunings) */ {
 public:
  PidTunings();
  virtual ~PidTunings();

  PidTunings(const PidTunings& from);

  inline PidTunings& operator=(const PidTunings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PidTunings& default_instance();

  static inline const PidTunings* internal_default_instance() {
    return reinterpret_cast<const PidTunings*>(
               &_PidTunings_default_instance_);
  }

  void Swap(PidTunings* other);

  // implements Message ----------------------------------------------

  inline PidTunings* New() const PROTOBUF_FINAL { return New(NULL); }

  PidTunings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PidTunings& from);
  void MergeFrom(const PidTunings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PidTunings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float p = 1;
  bool has_p() const;
  void clear_p();
  static const int kPFieldNumber = 1;
  float p() const;
  void set_p(float value);

  // required float i = 2;
  bool has_i() const;
  void clear_i();
  static const int kIFieldNumber = 2;
  float i() const;
  void set_i(float value);

  // required float d = 3;
  bool has_d() const;
  void clear_d();
  static const int kDFieldNumber = 3;
  float d() const;
  void set_d(float value);

  // @@protoc_insertion_point(class_scope:snd_msgs.PidTunings)
 private:
  void set_has_p();
  void clear_has_p();
  void set_has_i();
  void clear_has_i();
  void set_has_d();
  void clear_has_d();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float p_;
  float i_;
  float d_;
  friend struct  protobuf_CommMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ir : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snd_msgs.Ir) */ {
 public:
  Ir();
  virtual ~Ir();

  Ir(const Ir& from);

  inline Ir& operator=(const Ir& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ir& default_instance();

  static inline const Ir* internal_default_instance() {
    return reinterpret_cast<const Ir*>(
               &_Ir_default_instance_);
  }

  void Swap(Ir* other);

  // implements Message ----------------------------------------------

  inline Ir* New() const PROTOBUF_FINAL { return New(NULL); }

  Ir* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ir& from);
  void MergeFrom(const Ir& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ir* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool left = 1;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  bool left() const;
  void set_left(bool value);

  // required bool center = 2;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 2;
  bool center() const;
  void set_center(bool value);

  // required bool right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  bool right() const;
  void set_right(bool value);

  // @@protoc_insertion_point(class_scope:snd_msgs.Ir)
 private:
  void set_has_left();
  void clear_has_left();
  void set_has_center();
  void clear_has_center();
  void set_has_right();
  void clear_has_right();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool left_;
  bool center_;
  bool right_;
  friend struct  protobuf_CommMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snd_msgs.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  inline Status* New() const PROTOBUF_FINAL { return New(NULL); }

  Status* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .snd_msgs.Speed speed = 2;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 2;
  const ::snd_msgs::Speed& speed() const;
  ::snd_msgs::Speed* mutable_speed();
  ::snd_msgs::Speed* release_speed();
  void set_allocated_speed(::snd_msgs::Speed* speed);

  // required .snd_msgs.Ir ir = 6;
  bool has_ir() const;
  void clear_ir();
  static const int kIrFieldNumber = 6;
  const ::snd_msgs::Ir& ir() const;
  ::snd_msgs::Ir* mutable_ir();
  ::snd_msgs::Ir* release_ir();
  void set_allocated_ir(::snd_msgs::Ir* ir);

  // required .snd_msgs.Encoders encoders = 7;
  bool has_encoders() const;
  void clear_encoders();
  static const int kEncodersFieldNumber = 7;
  const ::snd_msgs::Encoders& encoders() const;
  ::snd_msgs::Encoders* mutable_encoders();
  ::snd_msgs::Encoders* release_encoders();
  void set_allocated_encoders(::snd_msgs::Encoders* encoders);

  // required bool starter = 3;
  bool has_starter() const;
  void clear_starter();
  static const int kStarterFieldNumber = 3;
  bool starter() const;
  void set_starter(bool value);

  // required bool estop = 4;
  bool has_estop() const;
  void clear_estop();
  static const int kEstopFieldNumber = 4;
  bool estop() const;
  void set_estop(bool value);

  // required .snd_msgs.eTeamColor colorSwitch = 5;
  bool has_colorswitch() const;
  void clear_colorswitch();
  static const int kColorSwitchFieldNumber = 5;
  ::snd_msgs::eTeamColor colorswitch() const;
  void set_colorswitch(::snd_msgs::eTeamColor value);

  // @@protoc_insertion_point(class_scope:snd_msgs.Status)
 private:
  void set_has_speed();
  void clear_has_speed();
  void set_has_starter();
  void clear_has_starter();
  void set_has_estop();
  void clear_has_estop();
  void set_has_colorswitch();
  void clear_has_colorswitch();
  void set_has_ir();
  void clear_has_ir();
  void set_has_encoders();
  void clear_has_encoders();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::snd_msgs::Speed* speed_;
  ::snd_msgs::Ir* ir_;
  ::snd_msgs::Encoders* encoders_;
  bool starter_;
  bool estop_;
  int colorswitch_;
  friend struct  protobuf_CommMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snd_msgs.Log) */ {
 public:
  Log();
  virtual ~Log();

  Log(const Log& from);

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log& default_instance();

  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }

  void Swap(Log* other);

  // implements Message ----------------------------------------------

  inline Log* New() const PROTOBUF_FINAL { return New(NULL); }

  Log* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Log* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Log_eLogLevel eLogLevel;
  static const eLogLevel DEBUG =
    Log_eLogLevel_DEBUG;
  static const eLogLevel INFO =
    Log_eLogLevel_INFO;
  static const eLogLevel WARN =
    Log_eLogLevel_WARN;
  static const eLogLevel ERROR =
    Log_eLogLevel_ERROR;
  static const eLogLevel FATAL =
    Log_eLogLevel_FATAL;
  static inline bool eLogLevel_IsValid(int value) {
    return Log_eLogLevel_IsValid(value);
  }
  static const eLogLevel eLogLevel_MIN =
    Log_eLogLevel_eLogLevel_MIN;
  static const eLogLevel eLogLevel_MAX =
    Log_eLogLevel_eLogLevel_MAX;
  static const int eLogLevel_ARRAYSIZE =
    Log_eLogLevel_eLogLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eLogLevel_descriptor() {
    return Log_eLogLevel_descriptor();
  }
  static inline const ::std::string& eLogLevel_Name(eLogLevel value) {
    return Log_eLogLevel_Name(value);
  }
  static inline bool eLogLevel_Parse(const ::std::string& name,
      eLogLevel* value) {
    return Log_eLogLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string text = 3;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 3;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // required uint32 stamp = 1;
  bool has_stamp() const;
  void clear_stamp();
  static const int kStampFieldNumber = 1;
  ::google::protobuf::uint32 stamp() const;
  void set_stamp(::google::protobuf::uint32 value);

  // required .snd_msgs.Log.eLogLevel level = 2 [default = INFO];
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  ::snd_msgs::Log_eLogLevel level() const;
  void set_level(::snd_msgs::Log_eLogLevel value);

  // @@protoc_insertion_point(class_scope:snd_msgs.Log)
 private:
  void set_has_stamp();
  void clear_has_stamp();
  void set_has_level();
  void clear_has_level();
  void set_has_text();
  void clear_has_text();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::uint32 stamp_;
  int level_;
  friend struct  protobuf_CommMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SerialRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snd_msgs.SerialRequest) */ {
 public:
  SerialRequest();
  virtual ~SerialRequest();

  SerialRequest(const SerialRequest& from);

  inline SerialRequest& operator=(const SerialRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialRequest& default_instance();

  enum TypeCase {
    kGetStatus = 1,
    kGetEncoders = 2,
    kGetPosition = 3,
    kGetMotorsSpeed = 4,
    kGetPidSpeedLeft = 5,
    kGetPidSpeedRight = 6,
    kGetStarterState = 7,
    kSetMotorsSpeed = 10,
    kSetPidSpeedLeft = 11,
    kSetPidSpeedRight = 12,
    kSetEncoders = 13,
    TYPE_NOT_SET = 0,
  };

  static inline const SerialRequest* internal_default_instance() {
    return reinterpret_cast<const SerialRequest*>(
               &_SerialRequest_default_instance_);
  }

  void Swap(SerialRequest* other);

  // implements Message ----------------------------------------------

  inline SerialRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SerialRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SerialRequest& from);
  void MergeFrom(const SerialRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SerialRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .snd_msgs.EmptyMsg getStatus = 1;
  bool has_getstatus() const;
  void clear_getstatus();
  static const int kGetStatusFieldNumber = 1;
  const ::snd_msgs::EmptyMsg& getstatus() const;
  ::snd_msgs::EmptyMsg* mutable_getstatus();
  ::snd_msgs::EmptyMsg* release_getstatus();
  void set_allocated_getstatus(::snd_msgs::EmptyMsg* getstatus);

  // optional .snd_msgs.EmptyMsg getEncoders = 2;
  bool has_getencoders() const;
  void clear_getencoders();
  static const int kGetEncodersFieldNumber = 2;
  const ::snd_msgs::EmptyMsg& getencoders() const;
  ::snd_msgs::EmptyMsg* mutable_getencoders();
  ::snd_msgs::EmptyMsg* release_getencoders();
  void set_allocated_getencoders(::snd_msgs::EmptyMsg* getencoders);

  // optional .snd_msgs.EmptyMsg getPosition = 3;
  bool has_getposition() const;
  void clear_getposition();
  static const int kGetPositionFieldNumber = 3;
  const ::snd_msgs::EmptyMsg& getposition() const;
  ::snd_msgs::EmptyMsg* mutable_getposition();
  ::snd_msgs::EmptyMsg* release_getposition();
  void set_allocated_getposition(::snd_msgs::EmptyMsg* getposition);

  // optional .snd_msgs.EmptyMsg getMotorsSpeed = 4;
  bool has_getmotorsspeed() const;
  void clear_getmotorsspeed();
  static const int kGetMotorsSpeedFieldNumber = 4;
  const ::snd_msgs::EmptyMsg& getmotorsspeed() const;
  ::snd_msgs::EmptyMsg* mutable_getmotorsspeed();
  ::snd_msgs::EmptyMsg* release_getmotorsspeed();
  void set_allocated_getmotorsspeed(::snd_msgs::EmptyMsg* getmotorsspeed);

  // optional .snd_msgs.EmptyMsg getPidSpeedLeft = 5;
  bool has_getpidspeedleft() const;
  void clear_getpidspeedleft();
  static const int kGetPidSpeedLeftFieldNumber = 5;
  const ::snd_msgs::EmptyMsg& getpidspeedleft() const;
  ::snd_msgs::EmptyMsg* mutable_getpidspeedleft();
  ::snd_msgs::EmptyMsg* release_getpidspeedleft();
  void set_allocated_getpidspeedleft(::snd_msgs::EmptyMsg* getpidspeedleft);

  // optional .snd_msgs.EmptyMsg getPidSpeedRight = 6;
  bool has_getpidspeedright() const;
  void clear_getpidspeedright();
  static const int kGetPidSpeedRightFieldNumber = 6;
  const ::snd_msgs::EmptyMsg& getpidspeedright() const;
  ::snd_msgs::EmptyMsg* mutable_getpidspeedright();
  ::snd_msgs::EmptyMsg* release_getpidspeedright();
  void set_allocated_getpidspeedright(::snd_msgs::EmptyMsg* getpidspeedright);

  // optional .snd_msgs.EmptyMsg getStarterState = 7;
  bool has_getstarterstate() const;
  void clear_getstarterstate();
  static const int kGetStarterStateFieldNumber = 7;
  const ::snd_msgs::EmptyMsg& getstarterstate() const;
  ::snd_msgs::EmptyMsg* mutable_getstarterstate();
  ::snd_msgs::EmptyMsg* release_getstarterstate();
  void set_allocated_getstarterstate(::snd_msgs::EmptyMsg* getstarterstate);

  // optional .snd_msgs.Speed setMotorsSpeed = 10;
  bool has_setmotorsspeed() const;
  void clear_setmotorsspeed();
  static const int kSetMotorsSpeedFieldNumber = 10;
  const ::snd_msgs::Speed& setmotorsspeed() const;
  ::snd_msgs::Speed* mutable_setmotorsspeed();
  ::snd_msgs::Speed* release_setmotorsspeed();
  void set_allocated_setmotorsspeed(::snd_msgs::Speed* setmotorsspeed);

  // optional .snd_msgs.PidTunings setPidSpeedLeft = 11;
  bool has_setpidspeedleft() const;
  void clear_setpidspeedleft();
  static const int kSetPidSpeedLeftFieldNumber = 11;
  const ::snd_msgs::PidTunings& setpidspeedleft() const;
  ::snd_msgs::PidTunings* mutable_setpidspeedleft();
  ::snd_msgs::PidTunings* release_setpidspeedleft();
  void set_allocated_setpidspeedleft(::snd_msgs::PidTunings* setpidspeedleft);

  // optional .snd_msgs.PidTunings setPidSpeedRight = 12;
  bool has_setpidspeedright() const;
  void clear_setpidspeedright();
  static const int kSetPidSpeedRightFieldNumber = 12;
  const ::snd_msgs::PidTunings& setpidspeedright() const;
  ::snd_msgs::PidTunings* mutable_setpidspeedright();
  ::snd_msgs::PidTunings* release_setpidspeedright();
  void set_allocated_setpidspeedright(::snd_msgs::PidTunings* setpidspeedright);

  // optional .snd_msgs.Encoders setEncoders = 13;
  bool has_setencoders() const;
  void clear_setencoders();
  static const int kSetEncodersFieldNumber = 13;
  const ::snd_msgs::Encoders& setencoders() const;
  ::snd_msgs::Encoders* mutable_setencoders();
  ::snd_msgs::Encoders* release_setencoders();
  void set_allocated_setencoders(::snd_msgs::Encoders* setencoders);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:snd_msgs.SerialRequest)
 private:
  void set_has_getstatus();
  void set_has_getencoders();
  void set_has_getposition();
  void set_has_getmotorsspeed();
  void set_has_getpidspeedleft();
  void set_has_getpidspeedright();
  void set_has_getstarterstate();
  void set_has_setmotorsspeed();
  void set_has_setpidspeedleft();
  void set_has_setpidspeedright();
  void set_has_setencoders();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  union TypeUnion {
    TypeUnion() {}
    ::snd_msgs::EmptyMsg* getstatus_;
    ::snd_msgs::EmptyMsg* getencoders_;
    ::snd_msgs::EmptyMsg* getposition_;
    ::snd_msgs::EmptyMsg* getmotorsspeed_;
    ::snd_msgs::EmptyMsg* getpidspeedleft_;
    ::snd_msgs::EmptyMsg* getpidspeedright_;
    ::snd_msgs::EmptyMsg* getstarterstate_;
    ::snd_msgs::Speed* setmotorsspeed_;
    ::snd_msgs::PidTunings* setpidspeedleft_;
    ::snd_msgs::PidTunings* setpidspeedright_;
    ::snd_msgs::Encoders* setencoders_;
  } type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_CommMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SerialResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snd_msgs.SerialResponse) */ {
 public:
  SerialResponse();
  virtual ~SerialResponse();

  SerialResponse(const SerialResponse& from);

  inline SerialResponse& operator=(const SerialResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialResponse& default_instance();

  enum TypeCase {
    kLog = 1,
    kEncoders = 2,
    kPose = 3,
    kSpeed = 4,
    kPidSpeedLeft = 5,
    kPidSpeedRight = 6,
    kIsStarterSet = 7,
    kStatus = 8,
    TYPE_NOT_SET = 0,
  };

  static inline const SerialResponse* internal_default_instance() {
    return reinterpret_cast<const SerialResponse*>(
               &_SerialResponse_default_instance_);
  }

  void Swap(SerialResponse* other);

  // implements Message ----------------------------------------------

  inline SerialResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SerialResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SerialResponse& from);
  void MergeFrom(const SerialResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SerialResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .snd_msgs.Log log = 1;
  bool has_log() const;
  void clear_log();
  static const int kLogFieldNumber = 1;
  const ::snd_msgs::Log& log() const;
  ::snd_msgs::Log* mutable_log();
  ::snd_msgs::Log* release_log();
  void set_allocated_log(::snd_msgs::Log* log);

  // optional .snd_msgs.Encoders encoders = 2;
  bool has_encoders() const;
  void clear_encoders();
  static const int kEncodersFieldNumber = 2;
  const ::snd_msgs::Encoders& encoders() const;
  ::snd_msgs::Encoders* mutable_encoders();
  ::snd_msgs::Encoders* release_encoders();
  void set_allocated_encoders(::snd_msgs::Encoders* encoders);

  // optional .snd_msgs.Pose pose = 3;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 3;
  const ::snd_msgs::Pose& pose() const;
  ::snd_msgs::Pose* mutable_pose();
  ::snd_msgs::Pose* release_pose();
  void set_allocated_pose(::snd_msgs::Pose* pose);

  // optional .snd_msgs.Speed speed = 4;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 4;
  const ::snd_msgs::Speed& speed() const;
  ::snd_msgs::Speed* mutable_speed();
  ::snd_msgs::Speed* release_speed();
  void set_allocated_speed(::snd_msgs::Speed* speed);

  // optional .snd_msgs.PidTunings pidSpeedLeft = 5;
  bool has_pidspeedleft() const;
  void clear_pidspeedleft();
  static const int kPidSpeedLeftFieldNumber = 5;
  const ::snd_msgs::PidTunings& pidspeedleft() const;
  ::snd_msgs::PidTunings* mutable_pidspeedleft();
  ::snd_msgs::PidTunings* release_pidspeedleft();
  void set_allocated_pidspeedleft(::snd_msgs::PidTunings* pidspeedleft);

  // optional .snd_msgs.PidTunings pidSpeedRight = 6;
  bool has_pidspeedright() const;
  void clear_pidspeedright();
  static const int kPidSpeedRightFieldNumber = 6;
  const ::snd_msgs::PidTunings& pidspeedright() const;
  ::snd_msgs::PidTunings* mutable_pidspeedright();
  ::snd_msgs::PidTunings* release_pidspeedright();
  void set_allocated_pidspeedright(::snd_msgs::PidTunings* pidspeedright);

  // optional bool isStarterSet = 7;
  bool has_isstarterset() const;
  void clear_isstarterset();
  static const int kIsStarterSetFieldNumber = 7;
  bool isstarterset() const;
  void set_isstarterset(bool value);

  // optional .snd_msgs.Status status = 8;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 8;
  const ::snd_msgs::Status& status() const;
  ::snd_msgs::Status* mutable_status();
  ::snd_msgs::Status* release_status();
  void set_allocated_status(::snd_msgs::Status* status);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:snd_msgs.SerialResponse)
 private:
  void set_has_log();
  void set_has_encoders();
  void set_has_pose();
  void set_has_speed();
  void set_has_pidspeedleft();
  void set_has_pidspeedright();
  void set_has_isstarterset();
  void set_has_status();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  union TypeUnion {
    TypeUnion() {}
    ::snd_msgs::Log* log_;
    ::snd_msgs::Encoders* encoders_;
    ::snd_msgs::Pose* pose_;
    ::snd_msgs::Speed* speed_;
    ::snd_msgs::PidTunings* pidspeedleft_;
    ::snd_msgs::PidTunings* pidspeedright_;
    bool isstarterset_;
    ::snd_msgs::Status* status_;
  } type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_CommMsgs_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// EmptyMsg

// -------------------------------------------------------------------

// Point

// required float x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Point::x() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Point.x)
  return x_;
}
inline void Point::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Point.x)
}

// required float y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Point::y() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Point.y)
  return y_;
}
inline void Point::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Point.y)
}

// -------------------------------------------------------------------

// Pose

// required float x = 1;
inline bool Pose::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Pose::x() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Pose.x)
  return x_;
}
inline void Pose::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Pose.x)
}

// required float y = 2;
inline bool Pose::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Pose::y() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Pose.y)
  return y_;
}
inline void Pose::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Pose.y)
}

// required float th = 3;
inline bool Pose::has_th() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pose::set_has_th() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pose::clear_has_th() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pose::clear_th() {
  th_ = 0;
  clear_has_th();
}
inline float Pose::th() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Pose.th)
  return th_;
}
inline void Pose::set_th(float value) {
  set_has_th();
  th_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Pose.th)
}

// -------------------------------------------------------------------

// Speed

// required float left = 1;
inline bool Speed::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Speed::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Speed::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Speed::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline float Speed::left() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Speed.left)
  return left_;
}
inline void Speed::set_left(float value) {
  set_has_left();
  left_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Speed.left)
}

// required float right = 2;
inline bool Speed::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Speed::set_has_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Speed::clear_has_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Speed::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline float Speed::right() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Speed.right)
  return right_;
}
inline void Speed::set_right(float value) {
  set_has_right();
  right_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Speed.right)
}

// -------------------------------------------------------------------

// Encoders

// required int32 left = 1;
inline bool Encoders::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Encoders::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Encoders::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Encoders::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 Encoders::left() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Encoders.left)
  return left_;
}
inline void Encoders::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Encoders.left)
}

// required int32 right = 2;
inline bool Encoders::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Encoders::set_has_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Encoders::clear_has_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Encoders::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 Encoders::right() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Encoders.right)
  return right_;
}
inline void Encoders::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Encoders.right)
}

// -------------------------------------------------------------------

// PidTunings

// required float p = 1;
inline bool PidTunings::has_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PidTunings::set_has_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PidTunings::clear_has_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PidTunings::clear_p() {
  p_ = 0;
  clear_has_p();
}
inline float PidTunings::p() const {
  // @@protoc_insertion_point(field_get:snd_msgs.PidTunings.p)
  return p_;
}
inline void PidTunings::set_p(float value) {
  set_has_p();
  p_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.PidTunings.p)
}

// required float i = 2;
inline bool PidTunings::has_i() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PidTunings::set_has_i() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PidTunings::clear_has_i() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PidTunings::clear_i() {
  i_ = 0;
  clear_has_i();
}
inline float PidTunings::i() const {
  // @@protoc_insertion_point(field_get:snd_msgs.PidTunings.i)
  return i_;
}
inline void PidTunings::set_i(float value) {
  set_has_i();
  i_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.PidTunings.i)
}

// required float d = 3;
inline bool PidTunings::has_d() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PidTunings::set_has_d() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PidTunings::clear_has_d() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PidTunings::clear_d() {
  d_ = 0;
  clear_has_d();
}
inline float PidTunings::d() const {
  // @@protoc_insertion_point(field_get:snd_msgs.PidTunings.d)
  return d_;
}
inline void PidTunings::set_d(float value) {
  set_has_d();
  d_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.PidTunings.d)
}

// -------------------------------------------------------------------

// Ir

// required bool left = 1;
inline bool Ir::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ir::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ir::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ir::clear_left() {
  left_ = false;
  clear_has_left();
}
inline bool Ir::left() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Ir.left)
  return left_;
}
inline void Ir::set_left(bool value) {
  set_has_left();
  left_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Ir.left)
}

// required bool center = 2;
inline bool Ir::has_center() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ir::set_has_center() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ir::clear_has_center() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ir::clear_center() {
  center_ = false;
  clear_has_center();
}
inline bool Ir::center() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Ir.center)
  return center_;
}
inline void Ir::set_center(bool value) {
  set_has_center();
  center_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Ir.center)
}

// required bool right = 3;
inline bool Ir::has_right() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ir::set_has_right() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ir::clear_has_right() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ir::clear_right() {
  right_ = false;
  clear_has_right();
}
inline bool Ir::right() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Ir.right)
  return right_;
}
inline void Ir::set_right(bool value) {
  set_has_right();
  right_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Ir.right)
}

// -------------------------------------------------------------------

// Status

// required .snd_msgs.Speed speed = 2;
inline bool Status::has_speed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_speed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_speed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_speed() {
  if (speed_ != NULL) speed_->::snd_msgs::Speed::Clear();
  clear_has_speed();
}
inline const ::snd_msgs::Speed& Status::speed() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Status.speed)
  return speed_ != NULL ? *speed_
                         : *::snd_msgs::Speed::internal_default_instance();
}
inline ::snd_msgs::Speed* Status::mutable_speed() {
  set_has_speed();
  if (speed_ == NULL) {
    speed_ = new ::snd_msgs::Speed;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.Status.speed)
  return speed_;
}
inline ::snd_msgs::Speed* Status::release_speed() {
  // @@protoc_insertion_point(field_release:snd_msgs.Status.speed)
  clear_has_speed();
  ::snd_msgs::Speed* temp = speed_;
  speed_ = NULL;
  return temp;
}
inline void Status::set_allocated_speed(::snd_msgs::Speed* speed) {
  delete speed_;
  speed_ = speed;
  if (speed) {
    set_has_speed();
  } else {
    clear_has_speed();
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.Status.speed)
}

// required bool starter = 3;
inline bool Status::has_starter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Status::set_has_starter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Status::clear_has_starter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Status::clear_starter() {
  starter_ = false;
  clear_has_starter();
}
inline bool Status::starter() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Status.starter)
  return starter_;
}
inline void Status::set_starter(bool value) {
  set_has_starter();
  starter_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Status.starter)
}

// required bool estop = 4;
inline bool Status::has_estop() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Status::set_has_estop() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Status::clear_has_estop() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Status::clear_estop() {
  estop_ = false;
  clear_has_estop();
}
inline bool Status::estop() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Status.estop)
  return estop_;
}
inline void Status::set_estop(bool value) {
  set_has_estop();
  estop_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Status.estop)
}

// required .snd_msgs.eTeamColor colorSwitch = 5;
inline bool Status::has_colorswitch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Status::set_has_colorswitch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Status::clear_has_colorswitch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Status::clear_colorswitch() {
  colorswitch_ = 0;
  clear_has_colorswitch();
}
inline ::snd_msgs::eTeamColor Status::colorswitch() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Status.colorSwitch)
  return static_cast< ::snd_msgs::eTeamColor >(colorswitch_);
}
inline void Status::set_colorswitch(::snd_msgs::eTeamColor value) {
  assert(::snd_msgs::eTeamColor_IsValid(value));
  set_has_colorswitch();
  colorswitch_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Status.colorSwitch)
}

// required .snd_msgs.Ir ir = 6;
inline bool Status::has_ir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_ir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_ir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_ir() {
  if (ir_ != NULL) ir_->::snd_msgs::Ir::Clear();
  clear_has_ir();
}
inline const ::snd_msgs::Ir& Status::ir() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Status.ir)
  return ir_ != NULL ? *ir_
                         : *::snd_msgs::Ir::internal_default_instance();
}
inline ::snd_msgs::Ir* Status::mutable_ir() {
  set_has_ir();
  if (ir_ == NULL) {
    ir_ = new ::snd_msgs::Ir;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.Status.ir)
  return ir_;
}
inline ::snd_msgs::Ir* Status::release_ir() {
  // @@protoc_insertion_point(field_release:snd_msgs.Status.ir)
  clear_has_ir();
  ::snd_msgs::Ir* temp = ir_;
  ir_ = NULL;
  return temp;
}
inline void Status::set_allocated_ir(::snd_msgs::Ir* ir) {
  delete ir_;
  ir_ = ir;
  if (ir) {
    set_has_ir();
  } else {
    clear_has_ir();
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.Status.ir)
}

// required .snd_msgs.Encoders encoders = 7;
inline bool Status::has_encoders() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Status::set_has_encoders() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Status::clear_has_encoders() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Status::clear_encoders() {
  if (encoders_ != NULL) encoders_->::snd_msgs::Encoders::Clear();
  clear_has_encoders();
}
inline const ::snd_msgs::Encoders& Status::encoders() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Status.encoders)
  return encoders_ != NULL ? *encoders_
                         : *::snd_msgs::Encoders::internal_default_instance();
}
inline ::snd_msgs::Encoders* Status::mutable_encoders() {
  set_has_encoders();
  if (encoders_ == NULL) {
    encoders_ = new ::snd_msgs::Encoders;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.Status.encoders)
  return encoders_;
}
inline ::snd_msgs::Encoders* Status::release_encoders() {
  // @@protoc_insertion_point(field_release:snd_msgs.Status.encoders)
  clear_has_encoders();
  ::snd_msgs::Encoders* temp = encoders_;
  encoders_ = NULL;
  return temp;
}
inline void Status::set_allocated_encoders(::snd_msgs::Encoders* encoders) {
  delete encoders_;
  encoders_ = encoders;
  if (encoders) {
    set_has_encoders();
  } else {
    clear_has_encoders();
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.Status.encoders)
}

// -------------------------------------------------------------------

// Log

// required uint32 stamp = 1;
inline bool Log::has_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Log::set_has_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Log::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Log::clear_stamp() {
  stamp_ = 0u;
  clear_has_stamp();
}
inline ::google::protobuf::uint32 Log::stamp() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Log.stamp)
  return stamp_;
}
inline void Log::set_stamp(::google::protobuf::uint32 value) {
  set_has_stamp();
  stamp_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Log.stamp)
}

// required .snd_msgs.Log.eLogLevel level = 2 [default = INFO];
inline bool Log::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Log::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Log::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Log::clear_level() {
  level_ = 1;
  clear_has_level();
}
inline ::snd_msgs::Log_eLogLevel Log::level() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Log.level)
  return static_cast< ::snd_msgs::Log_eLogLevel >(level_);
}
inline void Log::set_level(::snd_msgs::Log_eLogLevel value) {
  assert(::snd_msgs::Log_eLogLevel_IsValid(value));
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.Log.level)
}

// required string text = 3;
inline bool Log::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Log::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Log::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Log::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Log::text() const {
  // @@protoc_insertion_point(field_get:snd_msgs.Log.text)
  return text_.GetNoArena();
}
inline void Log::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:snd_msgs.Log.text)
}
#if LANG_CXX11
inline void Log::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:snd_msgs.Log.text)
}
#endif
inline void Log::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:snd_msgs.Log.text)
}
inline void Log::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:snd_msgs.Log.text)
}
inline ::std::string* Log::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:snd_msgs.Log.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log::release_text() {
  // @@protoc_insertion_point(field_release:snd_msgs.Log.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.Log.text)
}

// -------------------------------------------------------------------

// SerialRequest

// optional .snd_msgs.EmptyMsg getStatus = 1;
inline bool SerialRequest::has_getstatus() const {
  return type_case() == kGetStatus;
}
inline void SerialRequest::set_has_getstatus() {
  _oneof_case_[0] = kGetStatus;
}
inline void SerialRequest::clear_getstatus() {
  if (has_getstatus()) {
    delete type_.getstatus_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::EmptyMsg& SerialRequest::getstatus() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialRequest.getStatus)
  return has_getstatus()
      ? *type_.getstatus_
      : ::snd_msgs::EmptyMsg::default_instance();
}
inline ::snd_msgs::EmptyMsg* SerialRequest::mutable_getstatus() {
  if (!has_getstatus()) {
    clear_type();
    set_has_getstatus();
    type_.getstatus_ = new ::snd_msgs::EmptyMsg;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialRequest.getStatus)
  return type_.getstatus_;
}
inline ::snd_msgs::EmptyMsg* SerialRequest::release_getstatus() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialRequest.getStatus)
  if (has_getstatus()) {
    clear_has_type();
    ::snd_msgs::EmptyMsg* temp = type_.getstatus_;
    type_.getstatus_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialRequest::set_allocated_getstatus(::snd_msgs::EmptyMsg* getstatus) {
  clear_type();
  if (getstatus) {
    set_has_getstatus();
    type_.getstatus_ = getstatus;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialRequest.getStatus)
}

// optional .snd_msgs.EmptyMsg getEncoders = 2;
inline bool SerialRequest::has_getencoders() const {
  return type_case() == kGetEncoders;
}
inline void SerialRequest::set_has_getencoders() {
  _oneof_case_[0] = kGetEncoders;
}
inline void SerialRequest::clear_getencoders() {
  if (has_getencoders()) {
    delete type_.getencoders_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::EmptyMsg& SerialRequest::getencoders() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialRequest.getEncoders)
  return has_getencoders()
      ? *type_.getencoders_
      : ::snd_msgs::EmptyMsg::default_instance();
}
inline ::snd_msgs::EmptyMsg* SerialRequest::mutable_getencoders() {
  if (!has_getencoders()) {
    clear_type();
    set_has_getencoders();
    type_.getencoders_ = new ::snd_msgs::EmptyMsg;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialRequest.getEncoders)
  return type_.getencoders_;
}
inline ::snd_msgs::EmptyMsg* SerialRequest::release_getencoders() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialRequest.getEncoders)
  if (has_getencoders()) {
    clear_has_type();
    ::snd_msgs::EmptyMsg* temp = type_.getencoders_;
    type_.getencoders_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialRequest::set_allocated_getencoders(::snd_msgs::EmptyMsg* getencoders) {
  clear_type();
  if (getencoders) {
    set_has_getencoders();
    type_.getencoders_ = getencoders;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialRequest.getEncoders)
}

// optional .snd_msgs.EmptyMsg getPosition = 3;
inline bool SerialRequest::has_getposition() const {
  return type_case() == kGetPosition;
}
inline void SerialRequest::set_has_getposition() {
  _oneof_case_[0] = kGetPosition;
}
inline void SerialRequest::clear_getposition() {
  if (has_getposition()) {
    delete type_.getposition_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::EmptyMsg& SerialRequest::getposition() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialRequest.getPosition)
  return has_getposition()
      ? *type_.getposition_
      : ::snd_msgs::EmptyMsg::default_instance();
}
inline ::snd_msgs::EmptyMsg* SerialRequest::mutable_getposition() {
  if (!has_getposition()) {
    clear_type();
    set_has_getposition();
    type_.getposition_ = new ::snd_msgs::EmptyMsg;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialRequest.getPosition)
  return type_.getposition_;
}
inline ::snd_msgs::EmptyMsg* SerialRequest::release_getposition() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialRequest.getPosition)
  if (has_getposition()) {
    clear_has_type();
    ::snd_msgs::EmptyMsg* temp = type_.getposition_;
    type_.getposition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialRequest::set_allocated_getposition(::snd_msgs::EmptyMsg* getposition) {
  clear_type();
  if (getposition) {
    set_has_getposition();
    type_.getposition_ = getposition;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialRequest.getPosition)
}

// optional .snd_msgs.EmptyMsg getMotorsSpeed = 4;
inline bool SerialRequest::has_getmotorsspeed() const {
  return type_case() == kGetMotorsSpeed;
}
inline void SerialRequest::set_has_getmotorsspeed() {
  _oneof_case_[0] = kGetMotorsSpeed;
}
inline void SerialRequest::clear_getmotorsspeed() {
  if (has_getmotorsspeed()) {
    delete type_.getmotorsspeed_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::EmptyMsg& SerialRequest::getmotorsspeed() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialRequest.getMotorsSpeed)
  return has_getmotorsspeed()
      ? *type_.getmotorsspeed_
      : ::snd_msgs::EmptyMsg::default_instance();
}
inline ::snd_msgs::EmptyMsg* SerialRequest::mutable_getmotorsspeed() {
  if (!has_getmotorsspeed()) {
    clear_type();
    set_has_getmotorsspeed();
    type_.getmotorsspeed_ = new ::snd_msgs::EmptyMsg;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialRequest.getMotorsSpeed)
  return type_.getmotorsspeed_;
}
inline ::snd_msgs::EmptyMsg* SerialRequest::release_getmotorsspeed() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialRequest.getMotorsSpeed)
  if (has_getmotorsspeed()) {
    clear_has_type();
    ::snd_msgs::EmptyMsg* temp = type_.getmotorsspeed_;
    type_.getmotorsspeed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialRequest::set_allocated_getmotorsspeed(::snd_msgs::EmptyMsg* getmotorsspeed) {
  clear_type();
  if (getmotorsspeed) {
    set_has_getmotorsspeed();
    type_.getmotorsspeed_ = getmotorsspeed;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialRequest.getMotorsSpeed)
}

// optional .snd_msgs.EmptyMsg getPidSpeedLeft = 5;
inline bool SerialRequest::has_getpidspeedleft() const {
  return type_case() == kGetPidSpeedLeft;
}
inline void SerialRequest::set_has_getpidspeedleft() {
  _oneof_case_[0] = kGetPidSpeedLeft;
}
inline void SerialRequest::clear_getpidspeedleft() {
  if (has_getpidspeedleft()) {
    delete type_.getpidspeedleft_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::EmptyMsg& SerialRequest::getpidspeedleft() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialRequest.getPidSpeedLeft)
  return has_getpidspeedleft()
      ? *type_.getpidspeedleft_
      : ::snd_msgs::EmptyMsg::default_instance();
}
inline ::snd_msgs::EmptyMsg* SerialRequest::mutable_getpidspeedleft() {
  if (!has_getpidspeedleft()) {
    clear_type();
    set_has_getpidspeedleft();
    type_.getpidspeedleft_ = new ::snd_msgs::EmptyMsg;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialRequest.getPidSpeedLeft)
  return type_.getpidspeedleft_;
}
inline ::snd_msgs::EmptyMsg* SerialRequest::release_getpidspeedleft() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialRequest.getPidSpeedLeft)
  if (has_getpidspeedleft()) {
    clear_has_type();
    ::snd_msgs::EmptyMsg* temp = type_.getpidspeedleft_;
    type_.getpidspeedleft_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialRequest::set_allocated_getpidspeedleft(::snd_msgs::EmptyMsg* getpidspeedleft) {
  clear_type();
  if (getpidspeedleft) {
    set_has_getpidspeedleft();
    type_.getpidspeedleft_ = getpidspeedleft;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialRequest.getPidSpeedLeft)
}

// optional .snd_msgs.EmptyMsg getPidSpeedRight = 6;
inline bool SerialRequest::has_getpidspeedright() const {
  return type_case() == kGetPidSpeedRight;
}
inline void SerialRequest::set_has_getpidspeedright() {
  _oneof_case_[0] = kGetPidSpeedRight;
}
inline void SerialRequest::clear_getpidspeedright() {
  if (has_getpidspeedright()) {
    delete type_.getpidspeedright_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::EmptyMsg& SerialRequest::getpidspeedright() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialRequest.getPidSpeedRight)
  return has_getpidspeedright()
      ? *type_.getpidspeedright_
      : ::snd_msgs::EmptyMsg::default_instance();
}
inline ::snd_msgs::EmptyMsg* SerialRequest::mutable_getpidspeedright() {
  if (!has_getpidspeedright()) {
    clear_type();
    set_has_getpidspeedright();
    type_.getpidspeedright_ = new ::snd_msgs::EmptyMsg;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialRequest.getPidSpeedRight)
  return type_.getpidspeedright_;
}
inline ::snd_msgs::EmptyMsg* SerialRequest::release_getpidspeedright() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialRequest.getPidSpeedRight)
  if (has_getpidspeedright()) {
    clear_has_type();
    ::snd_msgs::EmptyMsg* temp = type_.getpidspeedright_;
    type_.getpidspeedright_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialRequest::set_allocated_getpidspeedright(::snd_msgs::EmptyMsg* getpidspeedright) {
  clear_type();
  if (getpidspeedright) {
    set_has_getpidspeedright();
    type_.getpidspeedright_ = getpidspeedright;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialRequest.getPidSpeedRight)
}

// optional .snd_msgs.EmptyMsg getStarterState = 7;
inline bool SerialRequest::has_getstarterstate() const {
  return type_case() == kGetStarterState;
}
inline void SerialRequest::set_has_getstarterstate() {
  _oneof_case_[0] = kGetStarterState;
}
inline void SerialRequest::clear_getstarterstate() {
  if (has_getstarterstate()) {
    delete type_.getstarterstate_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::EmptyMsg& SerialRequest::getstarterstate() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialRequest.getStarterState)
  return has_getstarterstate()
      ? *type_.getstarterstate_
      : ::snd_msgs::EmptyMsg::default_instance();
}
inline ::snd_msgs::EmptyMsg* SerialRequest::mutable_getstarterstate() {
  if (!has_getstarterstate()) {
    clear_type();
    set_has_getstarterstate();
    type_.getstarterstate_ = new ::snd_msgs::EmptyMsg;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialRequest.getStarterState)
  return type_.getstarterstate_;
}
inline ::snd_msgs::EmptyMsg* SerialRequest::release_getstarterstate() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialRequest.getStarterState)
  if (has_getstarterstate()) {
    clear_has_type();
    ::snd_msgs::EmptyMsg* temp = type_.getstarterstate_;
    type_.getstarterstate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialRequest::set_allocated_getstarterstate(::snd_msgs::EmptyMsg* getstarterstate) {
  clear_type();
  if (getstarterstate) {
    set_has_getstarterstate();
    type_.getstarterstate_ = getstarterstate;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialRequest.getStarterState)
}

// optional .snd_msgs.Speed setMotorsSpeed = 10;
inline bool SerialRequest::has_setmotorsspeed() const {
  return type_case() == kSetMotorsSpeed;
}
inline void SerialRequest::set_has_setmotorsspeed() {
  _oneof_case_[0] = kSetMotorsSpeed;
}
inline void SerialRequest::clear_setmotorsspeed() {
  if (has_setmotorsspeed()) {
    delete type_.setmotorsspeed_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::Speed& SerialRequest::setmotorsspeed() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialRequest.setMotorsSpeed)
  return has_setmotorsspeed()
      ? *type_.setmotorsspeed_
      : ::snd_msgs::Speed::default_instance();
}
inline ::snd_msgs::Speed* SerialRequest::mutable_setmotorsspeed() {
  if (!has_setmotorsspeed()) {
    clear_type();
    set_has_setmotorsspeed();
    type_.setmotorsspeed_ = new ::snd_msgs::Speed;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialRequest.setMotorsSpeed)
  return type_.setmotorsspeed_;
}
inline ::snd_msgs::Speed* SerialRequest::release_setmotorsspeed() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialRequest.setMotorsSpeed)
  if (has_setmotorsspeed()) {
    clear_has_type();
    ::snd_msgs::Speed* temp = type_.setmotorsspeed_;
    type_.setmotorsspeed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialRequest::set_allocated_setmotorsspeed(::snd_msgs::Speed* setmotorsspeed) {
  clear_type();
  if (setmotorsspeed) {
    set_has_setmotorsspeed();
    type_.setmotorsspeed_ = setmotorsspeed;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialRequest.setMotorsSpeed)
}

// optional .snd_msgs.PidTunings setPidSpeedLeft = 11;
inline bool SerialRequest::has_setpidspeedleft() const {
  return type_case() == kSetPidSpeedLeft;
}
inline void SerialRequest::set_has_setpidspeedleft() {
  _oneof_case_[0] = kSetPidSpeedLeft;
}
inline void SerialRequest::clear_setpidspeedleft() {
  if (has_setpidspeedleft()) {
    delete type_.setpidspeedleft_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::PidTunings& SerialRequest::setpidspeedleft() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialRequest.setPidSpeedLeft)
  return has_setpidspeedleft()
      ? *type_.setpidspeedleft_
      : ::snd_msgs::PidTunings::default_instance();
}
inline ::snd_msgs::PidTunings* SerialRequest::mutable_setpidspeedleft() {
  if (!has_setpidspeedleft()) {
    clear_type();
    set_has_setpidspeedleft();
    type_.setpidspeedleft_ = new ::snd_msgs::PidTunings;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialRequest.setPidSpeedLeft)
  return type_.setpidspeedleft_;
}
inline ::snd_msgs::PidTunings* SerialRequest::release_setpidspeedleft() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialRequest.setPidSpeedLeft)
  if (has_setpidspeedleft()) {
    clear_has_type();
    ::snd_msgs::PidTunings* temp = type_.setpidspeedleft_;
    type_.setpidspeedleft_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialRequest::set_allocated_setpidspeedleft(::snd_msgs::PidTunings* setpidspeedleft) {
  clear_type();
  if (setpidspeedleft) {
    set_has_setpidspeedleft();
    type_.setpidspeedleft_ = setpidspeedleft;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialRequest.setPidSpeedLeft)
}

// optional .snd_msgs.PidTunings setPidSpeedRight = 12;
inline bool SerialRequest::has_setpidspeedright() const {
  return type_case() == kSetPidSpeedRight;
}
inline void SerialRequest::set_has_setpidspeedright() {
  _oneof_case_[0] = kSetPidSpeedRight;
}
inline void SerialRequest::clear_setpidspeedright() {
  if (has_setpidspeedright()) {
    delete type_.setpidspeedright_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::PidTunings& SerialRequest::setpidspeedright() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialRequest.setPidSpeedRight)
  return has_setpidspeedright()
      ? *type_.setpidspeedright_
      : ::snd_msgs::PidTunings::default_instance();
}
inline ::snd_msgs::PidTunings* SerialRequest::mutable_setpidspeedright() {
  if (!has_setpidspeedright()) {
    clear_type();
    set_has_setpidspeedright();
    type_.setpidspeedright_ = new ::snd_msgs::PidTunings;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialRequest.setPidSpeedRight)
  return type_.setpidspeedright_;
}
inline ::snd_msgs::PidTunings* SerialRequest::release_setpidspeedright() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialRequest.setPidSpeedRight)
  if (has_setpidspeedright()) {
    clear_has_type();
    ::snd_msgs::PidTunings* temp = type_.setpidspeedright_;
    type_.setpidspeedright_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialRequest::set_allocated_setpidspeedright(::snd_msgs::PidTunings* setpidspeedright) {
  clear_type();
  if (setpidspeedright) {
    set_has_setpidspeedright();
    type_.setpidspeedright_ = setpidspeedright;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialRequest.setPidSpeedRight)
}

// optional .snd_msgs.Encoders setEncoders = 13;
inline bool SerialRequest::has_setencoders() const {
  return type_case() == kSetEncoders;
}
inline void SerialRequest::set_has_setencoders() {
  _oneof_case_[0] = kSetEncoders;
}
inline void SerialRequest::clear_setencoders() {
  if (has_setencoders()) {
    delete type_.setencoders_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::Encoders& SerialRequest::setencoders() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialRequest.setEncoders)
  return has_setencoders()
      ? *type_.setencoders_
      : ::snd_msgs::Encoders::default_instance();
}
inline ::snd_msgs::Encoders* SerialRequest::mutable_setencoders() {
  if (!has_setencoders()) {
    clear_type();
    set_has_setencoders();
    type_.setencoders_ = new ::snd_msgs::Encoders;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialRequest.setEncoders)
  return type_.setencoders_;
}
inline ::snd_msgs::Encoders* SerialRequest::release_setencoders() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialRequest.setEncoders)
  if (has_setencoders()) {
    clear_has_type();
    ::snd_msgs::Encoders* temp = type_.setencoders_;
    type_.setencoders_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialRequest::set_allocated_setencoders(::snd_msgs::Encoders* setencoders) {
  clear_type();
  if (setencoders) {
    set_has_setencoders();
    type_.setencoders_ = setencoders;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialRequest.setEncoders)
}

inline bool SerialRequest::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void SerialRequest::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline SerialRequest::TypeCase SerialRequest::type_case() const {
  return SerialRequest::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SerialResponse

// optional .snd_msgs.Log log = 1;
inline bool SerialResponse::has_log() const {
  return type_case() == kLog;
}
inline void SerialResponse::set_has_log() {
  _oneof_case_[0] = kLog;
}
inline void SerialResponse::clear_log() {
  if (has_log()) {
    delete type_.log_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::Log& SerialResponse::log() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialResponse.log)
  return has_log()
      ? *type_.log_
      : ::snd_msgs::Log::default_instance();
}
inline ::snd_msgs::Log* SerialResponse::mutable_log() {
  if (!has_log()) {
    clear_type();
    set_has_log();
    type_.log_ = new ::snd_msgs::Log;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialResponse.log)
  return type_.log_;
}
inline ::snd_msgs::Log* SerialResponse::release_log() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialResponse.log)
  if (has_log()) {
    clear_has_type();
    ::snd_msgs::Log* temp = type_.log_;
    type_.log_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialResponse::set_allocated_log(::snd_msgs::Log* log) {
  clear_type();
  if (log) {
    set_has_log();
    type_.log_ = log;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialResponse.log)
}

// optional .snd_msgs.Encoders encoders = 2;
inline bool SerialResponse::has_encoders() const {
  return type_case() == kEncoders;
}
inline void SerialResponse::set_has_encoders() {
  _oneof_case_[0] = kEncoders;
}
inline void SerialResponse::clear_encoders() {
  if (has_encoders()) {
    delete type_.encoders_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::Encoders& SerialResponse::encoders() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialResponse.encoders)
  return has_encoders()
      ? *type_.encoders_
      : ::snd_msgs::Encoders::default_instance();
}
inline ::snd_msgs::Encoders* SerialResponse::mutable_encoders() {
  if (!has_encoders()) {
    clear_type();
    set_has_encoders();
    type_.encoders_ = new ::snd_msgs::Encoders;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialResponse.encoders)
  return type_.encoders_;
}
inline ::snd_msgs::Encoders* SerialResponse::release_encoders() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialResponse.encoders)
  if (has_encoders()) {
    clear_has_type();
    ::snd_msgs::Encoders* temp = type_.encoders_;
    type_.encoders_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialResponse::set_allocated_encoders(::snd_msgs::Encoders* encoders) {
  clear_type();
  if (encoders) {
    set_has_encoders();
    type_.encoders_ = encoders;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialResponse.encoders)
}

// optional .snd_msgs.Pose pose = 3;
inline bool SerialResponse::has_pose() const {
  return type_case() == kPose;
}
inline void SerialResponse::set_has_pose() {
  _oneof_case_[0] = kPose;
}
inline void SerialResponse::clear_pose() {
  if (has_pose()) {
    delete type_.pose_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::Pose& SerialResponse::pose() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialResponse.pose)
  return has_pose()
      ? *type_.pose_
      : ::snd_msgs::Pose::default_instance();
}
inline ::snd_msgs::Pose* SerialResponse::mutable_pose() {
  if (!has_pose()) {
    clear_type();
    set_has_pose();
    type_.pose_ = new ::snd_msgs::Pose;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialResponse.pose)
  return type_.pose_;
}
inline ::snd_msgs::Pose* SerialResponse::release_pose() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialResponse.pose)
  if (has_pose()) {
    clear_has_type();
    ::snd_msgs::Pose* temp = type_.pose_;
    type_.pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialResponse::set_allocated_pose(::snd_msgs::Pose* pose) {
  clear_type();
  if (pose) {
    set_has_pose();
    type_.pose_ = pose;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialResponse.pose)
}

// optional .snd_msgs.Speed speed = 4;
inline bool SerialResponse::has_speed() const {
  return type_case() == kSpeed;
}
inline void SerialResponse::set_has_speed() {
  _oneof_case_[0] = kSpeed;
}
inline void SerialResponse::clear_speed() {
  if (has_speed()) {
    delete type_.speed_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::Speed& SerialResponse::speed() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialResponse.speed)
  return has_speed()
      ? *type_.speed_
      : ::snd_msgs::Speed::default_instance();
}
inline ::snd_msgs::Speed* SerialResponse::mutable_speed() {
  if (!has_speed()) {
    clear_type();
    set_has_speed();
    type_.speed_ = new ::snd_msgs::Speed;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialResponse.speed)
  return type_.speed_;
}
inline ::snd_msgs::Speed* SerialResponse::release_speed() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialResponse.speed)
  if (has_speed()) {
    clear_has_type();
    ::snd_msgs::Speed* temp = type_.speed_;
    type_.speed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialResponse::set_allocated_speed(::snd_msgs::Speed* speed) {
  clear_type();
  if (speed) {
    set_has_speed();
    type_.speed_ = speed;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialResponse.speed)
}

// optional .snd_msgs.PidTunings pidSpeedLeft = 5;
inline bool SerialResponse::has_pidspeedleft() const {
  return type_case() == kPidSpeedLeft;
}
inline void SerialResponse::set_has_pidspeedleft() {
  _oneof_case_[0] = kPidSpeedLeft;
}
inline void SerialResponse::clear_pidspeedleft() {
  if (has_pidspeedleft()) {
    delete type_.pidspeedleft_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::PidTunings& SerialResponse::pidspeedleft() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialResponse.pidSpeedLeft)
  return has_pidspeedleft()
      ? *type_.pidspeedleft_
      : ::snd_msgs::PidTunings::default_instance();
}
inline ::snd_msgs::PidTunings* SerialResponse::mutable_pidspeedleft() {
  if (!has_pidspeedleft()) {
    clear_type();
    set_has_pidspeedleft();
    type_.pidspeedleft_ = new ::snd_msgs::PidTunings;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialResponse.pidSpeedLeft)
  return type_.pidspeedleft_;
}
inline ::snd_msgs::PidTunings* SerialResponse::release_pidspeedleft() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialResponse.pidSpeedLeft)
  if (has_pidspeedleft()) {
    clear_has_type();
    ::snd_msgs::PidTunings* temp = type_.pidspeedleft_;
    type_.pidspeedleft_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialResponse::set_allocated_pidspeedleft(::snd_msgs::PidTunings* pidspeedleft) {
  clear_type();
  if (pidspeedleft) {
    set_has_pidspeedleft();
    type_.pidspeedleft_ = pidspeedleft;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialResponse.pidSpeedLeft)
}

// optional .snd_msgs.PidTunings pidSpeedRight = 6;
inline bool SerialResponse::has_pidspeedright() const {
  return type_case() == kPidSpeedRight;
}
inline void SerialResponse::set_has_pidspeedright() {
  _oneof_case_[0] = kPidSpeedRight;
}
inline void SerialResponse::clear_pidspeedright() {
  if (has_pidspeedright()) {
    delete type_.pidspeedright_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::PidTunings& SerialResponse::pidspeedright() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialResponse.pidSpeedRight)
  return has_pidspeedright()
      ? *type_.pidspeedright_
      : ::snd_msgs::PidTunings::default_instance();
}
inline ::snd_msgs::PidTunings* SerialResponse::mutable_pidspeedright() {
  if (!has_pidspeedright()) {
    clear_type();
    set_has_pidspeedright();
    type_.pidspeedright_ = new ::snd_msgs::PidTunings;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialResponse.pidSpeedRight)
  return type_.pidspeedright_;
}
inline ::snd_msgs::PidTunings* SerialResponse::release_pidspeedright() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialResponse.pidSpeedRight)
  if (has_pidspeedright()) {
    clear_has_type();
    ::snd_msgs::PidTunings* temp = type_.pidspeedright_;
    type_.pidspeedright_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialResponse::set_allocated_pidspeedright(::snd_msgs::PidTunings* pidspeedright) {
  clear_type();
  if (pidspeedright) {
    set_has_pidspeedright();
    type_.pidspeedright_ = pidspeedright;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialResponse.pidSpeedRight)
}

// optional bool isStarterSet = 7;
inline bool SerialResponse::has_isstarterset() const {
  return type_case() == kIsStarterSet;
}
inline void SerialResponse::set_has_isstarterset() {
  _oneof_case_[0] = kIsStarterSet;
}
inline void SerialResponse::clear_isstarterset() {
  if (has_isstarterset()) {
    type_.isstarterset_ = false;
    clear_has_type();
  }
}
inline bool SerialResponse::isstarterset() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialResponse.isStarterSet)
  if (has_isstarterset()) {
    return type_.isstarterset_;
  }
  return false;
}
inline void SerialResponse::set_isstarterset(bool value) {
  if (!has_isstarterset()) {
    clear_type();
    set_has_isstarterset();
  }
  type_.isstarterset_ = value;
  // @@protoc_insertion_point(field_set:snd_msgs.SerialResponse.isStarterSet)
}

// optional .snd_msgs.Status status = 8;
inline bool SerialResponse::has_status() const {
  return type_case() == kStatus;
}
inline void SerialResponse::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void SerialResponse::clear_status() {
  if (has_status()) {
    delete type_.status_;
    clear_has_type();
  }
}
inline  const ::snd_msgs::Status& SerialResponse::status() const {
  // @@protoc_insertion_point(field_get:snd_msgs.SerialResponse.status)
  return has_status()
      ? *type_.status_
      : ::snd_msgs::Status::default_instance();
}
inline ::snd_msgs::Status* SerialResponse::mutable_status() {
  if (!has_status()) {
    clear_type();
    set_has_status();
    type_.status_ = new ::snd_msgs::Status;
  }
  // @@protoc_insertion_point(field_mutable:snd_msgs.SerialResponse.status)
  return type_.status_;
}
inline ::snd_msgs::Status* SerialResponse::release_status() {
  // @@protoc_insertion_point(field_release:snd_msgs.SerialResponse.status)
  if (has_status()) {
    clear_has_type();
    ::snd_msgs::Status* temp = type_.status_;
    type_.status_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SerialResponse::set_allocated_status(::snd_msgs::Status* status) {
  clear_type();
  if (status) {
    set_has_status();
    type_.status_ = status;
  }
  // @@protoc_insertion_point(field_set_allocated:snd_msgs.SerialResponse.status)
}

inline bool SerialResponse::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void SerialResponse::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline SerialResponse::TypeCase SerialResponse::type_case() const {
  return SerialResponse::TypeCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace snd_msgs

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::snd_msgs::Log_eLogLevel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snd_msgs::Log_eLogLevel>() {
  return ::snd_msgs::Log_eLogLevel_descriptor();
}
template <> struct is_proto_enum< ::snd_msgs::eTeamColor> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snd_msgs::eTeamColor>() {
  return ::snd_msgs::eTeamColor_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CommMsgs_2eproto__INCLUDED
